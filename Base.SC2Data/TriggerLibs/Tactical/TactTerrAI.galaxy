//--------------------------------------------------------------------------------------------------
//  *** Tactical Terran AI ***
//--------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------
//  Set Nuke Constants
//--------------------------------------------------------------------------------------------------
void AISetNukeConstants (int player) {
    AISetNukeGhost(player, c_TU_Ghost);
    AISetNukeNukeEffect(player, c_EF_Nuke);
    AISetNukeCloak(player, c_TR_GhostCloak);
    AISetNukeNukeAbilLink(player, c_AB_Nuke);
    AISetNukeCloakAbilLink(player, c_AB_GhostCloak);
    
    AISetNukeCloakRegenRate(player, AIBehaviorFixed(player, c_BF_PersonalCloaking, c_fieldModification0));
    AISetNukeCloakCost(player, AIAbilityFixed(player, c_AB_GhostCloak, c_fieldEnergyCost));
    AISetNukeNukeCastTime(player, 20);

    AISetNukeDamage(player, AIEffectFixed(player, c_EF_NukeDamage, c_fieldAmount), AIEffectFixed(player, c_EF_NukeDamage, c_fieldAttrStructure));
    AISetNukeRadiusClose(player, AIEffectFixed(player, c_EF_NukeDamage, c_fieldAreaRadius0), AIEffectFixed(player, c_EF_NukeDamage, c_fieldAreaFraction0));
    AISetNukeRadiusMedium(player, AIEffectFixed(player, c_EF_NukeDamage, c_fieldAreaRadius1), AIEffectFixed(player, c_EF_NukeDamage, c_fieldAreaFraction1));
    AISetNukeRadiusFar(player, AIEffectFixed(player, c_EF_NukeDamage, c_fieldAreaRadius2), AIEffectFixed(player, c_EF_NukeDamage, c_fieldAreaFraction2));
}

//--------------------------------------------------------------------------------------------------
//  *** GHOST ***
//--------------------------------------------------------------------------------------------------
const int c_snipeCooldown = c_tactTimerFirst;

//---------------------------------------------------------------------------------------------
order AIOrderSteadyTargeting (int player, unit aiUnit, unitgroup scanGroup, marker mark) {
    order ord;
    fixed damage;
    aifilter filterAI;
    unitfilter filterUnit;
    unitgroup targetGroup;

    if (!AITactCooldownAllow(aiUnit, c_snipeCooldown)) {
        return null;
    }
    
    // Check UnitAbilityExists to prevent warnings in liberty/swarm
    if (!UnitAbilityExists(aiUnit, c_AB_SteadyTargeting)) {
        return null;
    }

    ord = AICreateOrder(player, c_AB_SteadyTargeting, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

    // don't try if we've been attacked recently (taking damage interrupts it).
    if (AILastAttack(aiUnit) > (AIGetTime() - 4.0)) {
        return null;
    }

    damage = AIEffectInt(player, c_EF_SteadyTargetingDamage, c_fieldAmount);

    filterUnit = UnitFilterStr(AIAbilityStr(player, c_AB_SteadyTargeting, c_fieldTargetFiltersAB));
    UnitFilterSetState(filterUnit, c_targetFilterHeroic, c_unitFilterExcluded);

    filterAI = AIFilter(player);
    AISetFilterAlliance(filterAI, c_playerGroupEnemy);
    AISetFilterBits(filterAI, filterUnit);
    AISetFilterRange(filterAI, aiUnit, AIAbilityFixed(player, c_AB_SteadyTargeting, c_fieldRange0) + 1);
    AISetFilterLifePerMarker(filterAI, damage, mark);
    AISetFilterLifeSortReference(filterAI, damage, damage*c_distanceFromDamage);

    //  Select starting from the end, to obtain the target that has health closest to snipe
    //  damage.
    //
    targetGroup = AIGetFilterGroup(filterAI, scanGroup);
    if (targetGroup == null) {
        return null;
    }

    return AIUnitGroupGetValidOrder(targetGroup, ord, aiUnit, c_backwards);
}

const int c_gameLoopsPerSecond = 16;
const int c_framesPerThink = 12;
const int c_secondsPerSnipe = 4;
const int c_ghostMaxRandom = c_gameLoopsPerSecond * c_secondsPerSnipe / c_framesPerThink;

//---------------------------------------------------------------------------------------------
void AIThinkGhost (int player, unit aiUnit, unitgroup scanGroup) {
    marker mark;
    order ord;
    fixed cooldown = 0.0;

    //  Add a delay on campaign.
    if (RandomInt(0, c_ghostMaxRandom) != 1) {
        return;
    }

    mark = AIMarker(aiUnit, c_MK_SteadyTargeting);
    ord = AIOrderSteadyTargeting(player, aiUnit, scanGroup, mark);
    if (ord != null) {
        if (AIPlayerDifficulty(player) < c_campAdvanced) {
            cooldown = 8.0;
        }
        else if (AIPlayerDifficulty(player) < c_campExpert) {
            cooldown = 3.0;
        }

        AICastCooldown(aiUnit, ord, mark, c_castHold, c_snipeCooldown, cooldown);
        return;
    }
}


//--------------------------------------------------------------------------------------------------
//  *** Viking
//--------------------------------------------------------------------------------------------------

point VikingModeChange (int player, unit aiUnit, unitgroup scanGroup, bool inAssault) {
    int scanCount;
    int inAir;
    int onGround;
    int cliffLevel;
    int testCliffLevel;
    string type = AIGetBullyType(aiUnit);
    point here = UnitGetPosition(aiUnit);
    point there;
    int inAirThreatToGroundCount;
    unitgroup targetGroupAll;
    unitgroup targetGroupGround;
    unitgroup targetGroupAir;
    unitgroup targetGroupAirThreatToGround;

    //  First, find all units within viking range.
    //
    targetGroupAll = UnitGroupFilterRegion(scanGroup, RegionCircle(here, AIWeaponFixed(player, c_WE_VikingFighter, c_fieldRange)+2), 0);

    //  Next, find the number of ground and air units within viking range.
    //
    targetGroupGround = UnitGroupFilterPlane(targetGroupAll, c_planeGround, 0);
    onGround = UnitGroupCount(targetGroupGround, c_unitCountAll);
    targetGroupAir = UnitGroupFilterPlane(targetGroupAll, c_planeAir, 0);
    inAir = UnitGroupCount(targetGroupAir, c_unitCountAll);

    //  If a bully type is set, check to see if we're in the right mode if idle.
    if (type != null && onGround == 0 && inAir == 0 && UnitOrderCount(aiUnit) == 0) {
        if (type == UnitGetType(aiUnit)) {
            return null;
        }
        else {
            return UnitGetPosition(aiUnit);
        }
    }

    if (inAssault) { // viking is on ground.
        //  Go to air mode when there's nothing on the ground anymore.
        //
        if (onGround == 0) {
            return UnitGetPosition(aiUnit);
        }
        
        //  Also, go to air mode when a pack of new air units shows up and we have killed most of the
        //  ground units.
        targetGroupAirThreatToGround = UnitGroupFilterThreat(targetGroupAir, aiUnit, null, 0);
        inAirThreatToGroundCount = UnitGroupCount(targetGroupAirThreatToGround, c_unitCountAlive);

        if (inAirThreatToGroundCount > 0) {  
            return UnitGetPosition(aiUnit);
        }
    }
    else { // viking is in air.
        //  If air targets remain, finish them off before switching.
        //
        if (inAir != 0) {
            return null;
        }

        if (onGround > 0) {
            cliffLevel = CliffLevel(here);
            
            //  Only switch if there is a ground target on the same or lower cliff level so that
            //  we are guaranteed to be able to navigate to it.
            //
            while (onGround > 0) {
                there = UnitGetPosition(UnitGroupUnit(targetGroupGround, onGround));
                testCliffLevel = CliffLevel(there);
                if (cliffLevel >= testCliffLevel) {
                    return there;
                }
                onGround = onGround - 1;
            }
        }
    }
    return null;
}

//--------------------------------------------------------------------------------------------------
//  *** VIKING (ground mode) ***
//--------------------------------------------------------------------------------------------------
void AIThinkVikingAssault (int player, unit aiUnit, unitgroup scanGroup) {
    order ord = AICreateOrder(player, c_AB_FighterMode, 0);
    unitgroup airGroup;
    int inAir;
    
    //  Check to see if this is a valid order at all.
    //
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return;
    }

    //  Check the number of air units to decide whether to ignore based on order count.
    //
    airGroup = UnitGroupFilterRegion(scanGroup, 
                                     RegionCircle(UnitGetPosition(aiUnit), AIWeaponFixed(player, c_WE_VikingFighter, c_fieldRange)+2), 
                                     0)
                                     ;
    airGroup = UnitGroupFilterPlane(airGroup, c_planeAir, 0);
    inAir = UnitGroupCount(airGroup, c_unitCountAlive);

    //  Do not switch to an air unit while processing an order on the ground. That way we won't
    //  interrupt the queued attack move order we get when we were told to land.
    //
    if (inAir == 0 && UnitOrderCount(aiUnit) > 0) {
        return;
    }

    if (VikingModeChange(player, aiUnit, scanGroup, true) == null) {
        return;
    }

    AICast(aiUnit, ord, c_noMarker, c_castHold);
}

//--------------------------------------------------------------------------------------------------
//  *** VIKING (air mode) ***
//--------------------------------------------------------------------------------------------------
void AIThinkVikingFighter (int player, unit aiUnit, unitgroup scanGroup) {
    point there;
    order ord = AICreateOrder(player, c_AB_AssaultMode, 0);

    if (!UnitOrderIsValid(aiUnit, ord)) {
        return;
    }

    there = VikingModeChange(player, aiUnit, scanGroup, false);
    if (there == null) {
        return;
    }

    AICast(aiUnit, ord, c_noMarker, c_castHold);

    //  Queue an attack move towards the threat to make sure we path past a LOS blocker.
    //
    AISetTacticalAttackTargetPoint(aiUnit, there);
}

//--------------------------------------------------------------------------------------------------
//  CargoDefend
//--------------------------------------------------------------------------------------------------
const fixed c_campaignBunkerLoadRange = 4.0;
const bool c_bunkerUnload = true;
const bool c_bunkerLoad = false;

//---------------------------------------------------------------------------------------------
unit CampaignWantsToBeInBunker (int player, unit aiUnit, unitgroup bunkerGroup, bool unload) {
    int bunkerCount;
    unit unitToCheck;
    bool wantsToBeInBunker;
    order unitOrder;

    //  When loading, check to see if there is space in the bunker at all.
    //
    if (!unload) {
        if (UnitCargoValue(aiUnit, c_unitCargoSpaceFree) == 0) {
            return null;
        }
    }

    bunkerCount = UnitGroupCount(bunkerGroup, c_unitCountAll);
    while (bunkerCount > 0) {
        unitToCheck = UnitGroupUnit(bunkerGroup, bunkerCount);
        bunkerCount = bunkerCount - 1;

        //  Make sure the unit is alive.
        //
        if (!UnitIsAlive(unitToCheck)) {
            continue;
        }
        if (AIIsScriptControlled(unitToCheck)) {
            continue;
        }
        //  When loading, make sure the unit is not already in a transport.
        //
        if (!unload) {
            if (UnitTestState(unitToCheck, c_unitStateInsideTransport)) {
                continue;
            }
        }

        //  The unit wants to be somewhere far away, do not load it.
        //
        wantsToBeInBunker = true;

        if (AIControlForceToMove(unitToCheck)) {
            // If the unit is forced to move, it shouldn't be in the bunker even in combat
            wantsToBeInBunker = false;
        }
        else if (!AIUnitIsInCombat(unitToCheck) && !AIUnitIsInCombat(aiUnit)) {
            // Otherwise the unit will only want to be out of the bunker if not combat is happening
            
            //  The unit wants to execute a non attack order.
            unitOrder = UnitOrder(aiUnit, 0);
            if (unitOrder != null && !AIIsAttackOrder(unitOrder)) {
                wantsToBeInBunker = false;
            }
            //  The unit wants to move.
            else if (AIControlWantsToMove(unitToCheck)) {
                wantsToBeInBunker = false;
            }
            // Unit has no home point
            else if (AIGetHomePosition(unitToCheck) == c_nullPoint) {
                wantsToBeInBunker = false;
            }
            // Unit's home point is too far away
            else if (!PointsInRange(UnitGetPosition(aiUnit), AIGetHomePosition(unitToCheck), c_campaignBunkerLoadRange)) {
                wantsToBeInBunker = false;
            }
        }

        //  Do not care about units that want to be in bunker when we want to unload.
        //  Similarly, do not care about units that do not want to be in bunker when we want to load.
        //
        if (wantsToBeInBunker == unload) {
            continue;
        }

        return unitToCheck;
    }
    return null;
}

//---------------------------------------------------------------------------------------------
bool CargoDefend (int player, unit aiUnit, unitgroup scanGroup, int searchRange, int loadRange, string wanted, string command) {
    aifilter filter;
    unitgroup nearBunkerGroup;
    int bunkerCount;
    unit unitToCheck;    
    order ord = null;
    bool autoLoad = false;
    bool wantsToBeInBunker;
    unitgroup targetGroup;

    targetGroup = UnitGroupFilterRegion(scanGroup, RegionCircle(UnitGetPosition(aiUnit), searchRange), 0);
    if (UnitGroupCount(targetGroup, c_unitCountAlive) == 0) { // no nearby enemies.

        //  Both checks are needed because auto loading bunkers is needed on campaign before the
        //  AI is active.....
        if (AIIsCampaign(player)) {
            autoLoad = true;
        }
        else if (AIGetDifficulty(player, c_diffAutoLoadBunkers)) {
            autoLoad = true;
        }

        if (autoLoad && (command == c_AB_BunkerChange)) {
            // handle bunkers on campaign differently.
            unitToCheck = CampaignWantsToBeInBunker(player, aiUnit, UnitCargoGroup(aiUnit), c_bunkerUnload);
            if (unitToCheck != null) {
                ord = AICreateOrder(player, command, e_AB_TransportUnloadUnit); // unload the bunker.
                OrderSetTargetPassenger(ord, unitToCheck);
            }

            if (ord == null) {
                nearBunkerGroup = AIFindUnits(player, wanted, UnitGetPosition(aiUnit), c_campaignBunkerLoadRange, c_noMaxCount);
                if (wanted == c_nullString) {
                    filter = AIFilter(player);
                    AISetFilterMelee(filter, c_onlyRanged);
                    AISetFilterValidPassenger(filter, aiUnit);
                    nearBunkerGroup = AIGetFilterGroup(filter, nearBunkerGroup);
                }

                unitToCheck = CampaignWantsToBeInBunker(player, aiUnit, nearBunkerGroup, c_bunkerLoad);
                if (unitToCheck != null) {
                    ord = AICreateOrder(player, command, e_AB_TransportLoadUnit); // load the bunker.
                    OrderSetTargetUnit(ord, unitToCheck);
                }
            }
        }
        else { // not a campaign bunker
            if (UnitCargoValue(aiUnit, c_unitCargoSpaceUsed) == 0) { // nothing to unload
                return false;
            }
            ord = AICreateOrder(player, command, e_AB_TransportUnloadAll); // unload bunker
        }
    }
    else { // nearby enemies found.
        if (UnitCargoValue(aiUnit, c_unitCargoSpaceFree) == 0) { // check for space
            return false;
        }

        if (command == c_AB_CommandCenterChange) {
            if (!AIAnyWorkersFleeingNearby(player,UnitGetPosition(aiUnit),8.0)) {
                return false;
            }
        }

        nearBunkerGroup = AIFindUnits(player, wanted, UnitGetPosition(aiUnit), loadRange, c_noMaxCount);
        if (wanted == c_nullString) {
            filter = AIFilter(player);
            AISetFilterMelee(filter, c_onlyRanged);
            AISetFilterValidPassenger(filter, aiUnit);
            nearBunkerGroup = AIGetFilterGroup(filter, nearBunkerGroup);
        }

        bunkerCount = UnitGroupCount(nearBunkerGroup, c_unitCountAll);
        while (bunkerCount > 0) {
            unitToCheck = UnitGroupUnit(nearBunkerGroup, bunkerCount);
            bunkerCount = bunkerCount - 1;

            if (!UnitIsAlive(unitToCheck)) {
                continue;
            }
            if (AIIsScriptControlled(unitToCheck)) {
                continue;
            }
            if (UnitTestState(unitToCheck, c_unitStateInsideTransport)) {
                continue;
            }
            
            if (command == c_AB_CommandCenterChange) {
                ord = AICreateOrder(player, command, e_AB_TransportLoadAll);
            }
            else {
                ord = AICreateOrder(player, command, e_AB_TransportLoadUnit);
                OrderSetTargetUnit(ord, unitToCheck);
            }
            break;
        }
    }
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }
    AICast(aiUnit, ord, c_noMarker, c_castHold);
    return true;
}


void AIThinkBunker(int player, unit aiUnit, unitgroup scanGroup) {
    CargoDefend(player, aiUnit, scanGroup, 8, 10, c_nullString, c_AB_BunkerChange);
}

//--------------------------------------------------------------------------------------------------
//  *** Raven ***
//--------------------------------------------------------------------------------------------------
const int c_autoTurretCooldown = c_tactTimerFirst;
const int c_hsMissileCooldown = c_tactTimerSecond;

const int c_seekerMissileMinMarker = 0;
const int c_seekerMissileMaxMarker = 0;

order HunterSeekerMissile (int player, unit aiUnit, unitgroup scanGroup, marker mark) {
    fixed damage;
    unitgroup targetGroup;
    aifilter filter;
    order ord;

    if (AIIsCampaign(player)) {
        if (AIPlayerDifficulty(player) < c_campAdvanced) {
            return null;
        }
    }

    if (!AITactCooldownAllow(aiUnit, c_hsMissileCooldown)) {
        return null;
    }

    ord = AITacticalOrder(player, aiUnit, c_AB_SeekerMissile);
    if (ord == null) {
        return null;
    }

    //  Create the filters
    //
    filter = AIFilter(player);
    AISetFilterBits(filter, UnitFilterStr(AIAbilityStr(player, c_AB_SeekerMissile, c_fieldTargetFiltersAB)));
    AISetFilterAlliance(filter, c_playerGroupEnemy);
    damage = AIEffectFixed(player, c_EF_SeekerDamage, c_fieldAmount);
    AISetFilterLife(filter, damage*c_minDamageFraction, c_noMax);
    AISetFilterMarker(filter, c_noMarkersMin, c_noMarkersMax, mark);
    AISetFilterLifeSortReference(filter, damage, damage*c_distanceFromDamage);
    
    //  Select starting from the end, which is the target who's health is closest to the missile's
    //  damage.
    //
    targetGroup = AIGetFilterGroup(filter, scanGroup);
    if (targetGroup == null) {
        return null;
    }

    return AIUnitGroupGetValidOrder(targetGroup, ord, aiUnit, c_backwards);
}

//---------------------------------------------------------------------------------------------
order PointDefenseDrone(int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    unit enemy;
    int scanCount;
    int enemyEval = 0;
    string enemyType;
    
    ord = AITacticalOrder(player, aiUnit, c_AB_PointDefenseDrone);
    if (ord == null) {
        return null;
    }

    OrderSetTargetPoint(ord, UnitGetPosition(aiUnit));
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return null;
    }

     scanCount = UnitGroupCount(scanGroup, c_unitCountAll);
     while (scanCount > 0) {
         enemy = UnitGroupUnit(scanGroup, scanCount);
         scanCount = scanCount - 1;
         enemyType = UnitGetType(enemy);
         
         if (enemyType == c_PU_Phoenix) {
            enemyEval += 2;
         }
         else if (enemyType == c_PU_Stalker) {
            enemyEval += 1;
         }
         else if (enemyType == c_TU_Battlecruiser) {
            enemyEval += 3;
         }
         else if (enemyType == c_TU_VikingAir) {
            enemyEval += 2;
         }
         else if (enemyType == c_ZU_Mutalisk) {
            enemyEval += 2;
         }
         else if (enemyType == c_ZU_Corruptor) {
            enemyEval += 2;
         }
         else if (enemyType == c_ZU_Hydralisk) {
            enemyEval += 1;
         }
     }

     if (enemyEval < 6) {
        return null;
     }

     return ord;
}

//---------------------------------------------------------------------------------------------
fixed minToCastAutoTurret(int player) {
    return AIAbilityFixed(player, c_AB_AutoTurret, c_fieldEnergyCost) + 
           AIAbilityFixed(player, c_AB_SeekerMissile, c_fieldEnergyCost);
}

//---------------------------------------------------------------------------------------------
static bool CastAutoTurret (int player, unit aiUnit, unitgroup scanGroup, bool lowVitality) {    
    // must not modify scanGroup in this function
    point loc;
    order ord = AITacticalOrder(player, aiUnit, c_AB_AutoTurret);
    order missleOrd;
    fixed minScore;
    fixed cooldown = 0.0;

    if (!AITactCooldownAllow(aiUnit, c_autoTurretCooldown)) {
        return false;
    }

    if (ord == null) {
        return false;
    }
    
    //  Relax the constraints a little if the raven is low on health.
    //
    if (lowVitality) {
        minScore = 0.5;
    }
    else {
        minScore = 1.5;
        
        // If Raven not low vitality, save enough energy for seeker missile.
        // Unless we've cast a missile recently, or we're a low difficulty campaign mission.
        if (AITactCooldownAllow(aiUnit, c_hsMissileCooldown)) {
            if (!AIIsCampaign(player) || AIPlayerDifficulty(player) >= c_campExpert) {
                missleOrd = AITacticalOrder(player, aiUnit, c_AB_SeekerMissile);
                if (missleOrd) {
                    if (UnitGetPropertyInt(aiUnit, c_unitPropEnergy, c_unitPropCurrent) < minToCastAutoTurret(player)) {
                        return false;
                    }
                }
            }
        }

    }

    //  Finds the best point for the ai to cast an area of effect spell.  The point must put the 
    //  turret in range of min hits targets, with an accumulative score GE 2.  Each target is assigned 
    //  a score of 0.0 to 1.0 points, depending on whether the target's vitality is from 0.0 to 40.0.
    //  Up to an additional 1.0 point can be rewarded if the target has the optional bonus attribute.
    //
    loc = AIBestTargetPoint(
        AIWeaponGroup(player, c_WE_AutoTurret, scanGroup),
        2, // min hits
        40, // damage base
        minScore, // min score
        AIWeaponFixed(player, c_WE_AutoTurret, c_fieldRange),
        UnitGetPosition(aiUnit),
        AIAbilityFixed(player, c_AB_AutoTurret, c_fieldRange0), 
        c_unitAttributeNone
    );
    if (loc == null) {
        return false;
    }
    OrderSetTargetPoint(ord, loc);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return false;
    }

    if (AIIsCampaign(player)) {
        if (AIPlayerDifficulty(player) < c_campAdvanced) {
            cooldown = 11.0;
        }
        else if (AIPlayerDifficulty(player) < c_campExpert) {
            cooldown = 7.0;
        }
    }

    AICastCooldown(aiUnit, ord, c_noMarker, c_castRetreat, c_autoTurretCooldown, cooldown);
    return true;
}

const int c_RavenLowVitalityPercent = 65;

//---------------------------------------------------------------------------------------------
void AIThinkRaven (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    marker mark;
    bool lowVitality;
    fixed cooldown;
    fixed sharedCoolDown = 0.0;

    if (AIIsCampaign(player)) {
        if (AIPlayerDifficulty(player) < c_campExpert) {
            sharedCoolDown = 10.0;
        }
        else {
            sharedCoolDown = 6.0;
        }
    }
    
    if (!AIIsCampaign(player)) {
        if (AIPlayerDifficulty(player) <= c_skirMedium) {
            // Medium and below won't use raven spells, only made for detection.
            return;
        }
    }

    //  Must not modify scanGroup because it will be used for CastAutoTurret.
    mark = AIMarker(aiUnit, c_MK_SeekerMissile);
    ord = HunterSeekerMissile(player, aiUnit, scanGroup, mark);
    if (ord != null) {
        if (AIIsCampaign(player)) {
            if (AIPlayerDifficulty(player) < c_campExpert) {
                cooldown = 11.0;
            }
            else {
                cooldown = 7.0;
            }
        }
        else {
            cooldown = 2.0;
        }
        AICastCooldown(aiUnit, ord, mark, c_castRetreat, c_hsMissileCooldown, cooldown);
        AISetCooldown(aiUnit, c_autoTurretCooldown, sharedCoolDown);
        return;
    }

    if (!AIIsCampaign(player)) {
        ord = PointDefenseDrone(player, aiUnit, scanGroup);
        if (ord != null) {
            AICast(aiUnit, ord, c_noMarker, c_castHold);
            return;
        }
    }

    lowVitality = UnitGetPropertyInt(aiUnit, c_unitPropVitalityPercent, c_unitPropCurrent) < c_RavenLowVitalityPercent;
    if (CastAutoTurret(player, aiUnit, scanGroup, lowVitality)) {
        AISetCooldown(aiUnit, c_hsMissileCooldown, sharedCoolDown);
        return;
    }
}

//--------------------------------------------------------------------------------------------------
//  *** Hellion ***
//--------------------------------------------------------------------------------------------------

void AIThinkHellion (int player, unit aiUnit, unitgroup scanGroup) {
    // In melee we don't take advantage of the speed anyway, just transform all hellions into tank
    // In campaign wait until there are enemies nearby.
    order ord;

    ord = AICreateOrder(player, c_AB_HellionToTank, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return;
    }

    if (AIIsCampaign(player)) {
        if (UnitGroupCount(scanGroup, c_unitCountAlive) <= 0) {
            return;
        }
    }

    AICast(aiUnit, ord, c_noMarker, c_castHold);
}

void AIThinkHellionTank (int player, unit aiUnit, unitgroup scanGroup) {
    // In melee we don't take advantage of the speed anyway, keep all hellions tank
    // In campaign stay in tank if there are enemies nearby, otherwise switch
    order ord;

    if (!AIIsCampaign(player)) {
        return;
    }
    if (UnitGroupCount(scanGroup, c_unitCountAlive) > 0) {
        return;
    }

    ord = AICreateOrder(player, c_AB_HellionLeaveTank, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return;
    }

    AICast(aiUnit, ord, c_noMarker, c_castHold);
}

//--------------------------------------------------------------------------------------------------
//  *** Widow Mine  ***
//--------------------------------------------------------------------------------------------------
void AIThinkWidowMine (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    order current;
    string type = AIGetBullyType(aiUnit);

    // wait until the order is legal
    ord = AICreateOrder(player, c_AB_WidowMineBurrow, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return;
    }

    // stay unburrowed while moving
    if (AIControlForceToMove(aiUnit)) {
        return;
    }
    if (AIControlWantsToMove(aiUnit)) {
        if (UnitGroupCount(scanGroup, c_unitCountAlive) == 0) {
            return;
        }
    }

    // stay as a unburrow when the order is not attack
    current = UnitOrder(aiUnit, 0);
    if (current != null) {
        if (!AIIsAttackOrder(current)) {
            return;
        }
    }

    //  Don't switch types if we're already in the bully type.
    if (type != null && type == UnitGetType(aiUnit)) {
        return;
    }

    AICast(aiUnit, ord, c_noMarker, c_castHold);
}

//--------------------------------------------------------------------------------------------------
//  *** Widow Mine Burrowed ***
//--------------------------------------------------------------------------------------------------
void AIThinkWidowMineBurrowed (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    aifilter filter;

    // wait until the order is legal
    ord = AICreateOrder(player, c_AB_WidowMineUnburrow, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return;
    }

    // always unburrow when we are forced to move
    if (AIControlForceToMove(aiUnit)) {
        AICast(aiUnit, ord, c_noMarker, c_castHold);
        return;
    }
    // unburrow if we want to move and aren't in combat
    if (AIControlWantsToMove(aiUnit)) {
        if (UnitGroupCount(scanGroup, c_unitCountAlive) == 0) {
            AICast(aiUnit, ord, c_noMarker, c_castHold);
            return;
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  *** Medivac ***
//--------------------------------------------------------------------------------------------------
void AIThinkMedivac (int player, unit aiUnit, unitgroup scanGroup) {
    order ord;
    aifilter filter;

    // wait until the order is legal
    ord = AICreateOrder(player, c_AB_MedivacSpeed, 0);
    if (!UnitOrderIsValid(aiUnit, ord)) {
        return;
    }

    // if we haven't been attacked recently, don't use it
    if (AILastAttack(aiUnit) < (AIGetTime() - 4.0)) {
        return;
    }

    // use it if an enemy is visible nearby
    if (UnitGroupCount(scanGroup, c_unitCountAlive) > 0) {
        AICast(aiUnit, ord, c_noMarker, c_castHold);
        return;
    }
}
